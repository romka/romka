---
title: Всё что нужно знать об IPFS перед началом её использования
date: 2025-01-31 13:49:11 +0100
draft: false
tags: [Работа, ipfs, туториал]
---
Коротко говоря, <strong>IPFS (InterPlanetary File System)</strong> -- это одноранговая распределённая сеть, позволяющая организовать хранение и распространение файлов. Любой желающий может присоединиться к сети для того чтобы начать распространять собственные данные и/или помочь распространению существующих в сети файлов. Архитектура системы была вдохновлена известными распределенными системами, в том числе _BitTorrent_, но в отличие от него дает дополнительные инструменты. Например, IPFS может быть использована для размещения статических веб-сайтов.

Для проекта написана отличная [документация](https://docs.ipfs.tech/concepts/), в которой можно найти ответы на все интересующие вопросы об этой системе. Для более глубкого понимания системы я рекомендую прочитать эту документацию, а также [оригинальную статью](ipfs-p2p-file-system.pdf) от авторов проекта. В этой статье я постараюсь максимально доступно и последовательно дать всю информацию, необходимую для того, чтобы читатель с нулевыми знаниями об IPFS смог понять основные принципы её работы. В следующем посте я расскажу о том как развернуть в IPFS собственный статический сайт. 

Помимо этого, я отвечу на самый важный вопрос -- а стоит ли игра свеч? Короткий ответ -- в общем случае нет, не стоит. Более развёрнутый вы найдете в конце статьи.

Текст будет разбит на следующие разделы:
1. Основные принципы функционирования сети и способы адресации,
2. Как взаимодействовать с IPFS,
3. Выводы
<!--more-->
 
## Основные принципы функционирования сети и способы адресации
В этом разделе я не буду вдаваться в технические подробности и детали реализации, а постараюсь верхнеуровнево объяснить терминологию и основные концепции IPFS. 

### Не файловая система

Первым делом надо отметить, что аббревиатура _FS_ в названии системы может вводить в заблуждение. IPFS не является полноценной POSIX-совместимой файловой системой. Её нельзя примонтировать в ОС и прозрачно использовать через привычные файловые менеджеры или API операционной системы. Есть [экспериментальная поддержка](https://github.com/ipfs/kubo/blob/11bfb3c93b9a69031cb536b07916d562e680d5e8/docs/fuse.md) работы IPFS как файловой системы доступной на чтение и, с некоторыми ограничениями, на запись, но эта тема выходит за рамки этой статьи.

По своей природе IPFS -- это распределённое хранилище типа ключ-значение, где ключами являются адреса файлов, а значениями -- их содержимое. Если быть еще точнее, то IPFS -- это распределённая хеш-таблица (distributed hash table, DHT). Другими словами это таблица состоящая из двух колонок, в первой колонке хранится ключ, по которому данные ищутся, во второй -- сами данные. Каждый из узлов системы хранит только часть таблицы, поэтому все узлы вместе могут хранить объем данных значительно превышающий ресурсы одного компьютера.
![DHT](simplified-dht.png)

Все данные хранящиеся в IPFS неизменяемы. Если нужно добавить в систему обновленную версию файла, то в хеш-таблицу будет добавлена новая строка, а старая со временем будет удалена сборщиком мусора. Идея неизменяемости данных противоречит идеям привычных файловых систем, где данные могут быть записаны, изменены, удалены, поэтому это нетривиально реализовать полноценную POSIX файловую систему поверх IPFS.

### Но почему данные неизменяемы и в чём смысл этого?

Каждый раз когда пользователь добавляет новый файл в IPFS, система вычисляет хеш-сумму этого файла (по-умолчанию используется алгоритм _sha-256_) и полученный хеш становится адресом файла. Вычисленный хеш файла в контексте IPFS называется **CID** -- _content identifier_. Пара ключ-значение, которая записывается в DHT -- это пара: `(CID, данные)`. Таким образом, в IPFS термины _хеш файла_, _IPFS-адрес файла_ и _CID_ являются синонимами. Эта концепция получила название _контентно-адресуемые данные_ (_content-addressed data_).
![DHT](dht.png)

Картинка выше иллюстрирует следующие идеи. Локальный файл `helloworld.txt` не попадает автоматически в IPFS. После добавления файла в IPFS для его содержимого вычисляется хеш, в данном примере `abc123`, и этот хеш используется как адрес файла. Две ноды на схеме распространяют один и тот же файл `funnycats.mp4`, одинаковость контента отражается тем, что у файлов одинаковый хеш `xyz789`. Также, каждая из двух нод выше распространяет файл `passwords.txt`, но это два разных файла, что приводит к тому, что у файлов разные адреса.

 Если пользователь локально меняет существующий файл, то, обновленный файл не будет автоматически добавлен в IPFS, его нужно добавить заново. При добавлении в IPFS изменённого файла для него опять будет посчитан CID, который почти со 100% вероятностью будет отличаться от старого. Как следствие, изменится и адрес обновлённого файла.
 ![File name change](dht2-change-file-content-merged.png)

И здесь мы подходим к ответу на вопрос "почему данные в IPFS неизменяемы?":

> На практике, невозможно изменить содержимое файла в IPFS не изменив его адрес.

Такая адресация удобна тем, что система гарантирует, что если вам прислали ссылку на файл и его удалось скачать, то это совершенно точно тот же файл, который изначально был загружен в систему (в данном случае я исхожу из того, что вероятность коллизий при подсчете хеша ничтожно мала).

Однако, такой подход не всегда приемлем. Например, в контексте создания веб-сайта очевидно, что файл главной страницы `index.html` будет обновляться довольно часто. Рассылать всем пользователям сайта новый CID изменённого index.html это явно не то чего хотят разработчики. Для таких случаев в IPFS предусмотрен механизм, называемый **IPNS -- InterPlanetary Name System**. Этот механизм схож с DNS: пользователь может создать **IP<em>N</em>S-адрес** -- псевдоним для IPFS-адреса, а затем, при необходимости, менять CID, на который ссылается этот псевдоним. В этом случае, очевидно, пропадает гарантия того, что сегодя и завтра по одному и тому же IPNS-адресу будет доступен один и тот же файл, но в контексте веб-хостинга это приемлемый компромисс -- IPNS-адрес главной страницы сайта всегда остаётся неизменным.

Важно учитывать, что IPNS-запись имеет время жизни (time to live, TTL) в 24 часа. Чтобы поддерживать её в работоспособном состоянии её необходимо обновлять прежде чем она "протухнет".

### Как IPFS хранит раздаваемые данные

Здесь важно рассказать еще об одной существенной особенности IPFS. Выше я говорил, что в момент когда файл добавляется из локальной файловой системы в IPFS, для него вычисляется CID, но это еще не всё. Каждый новый добавленный файл разбивается на блоки по 256 Кб и эти блоки _копируются_ в директорию с мета-данным IPFS. Если один файл распространяется несколькими узлами IPFS, то пользователь скачивающий файл, прямо как в BitTorrent, имеет возможность скачать разные блоки с разных узлов, даже если эти узлы сами скачали не весь файл, а только часть его блоков. Это снижает нагрузку с каждого отдельного узла раздающего файл и в целом повышает надёжность и скорость системы.

Однако такое решение имеет и обратную сторону. Копирование файлов в IPFS означает, что 

> узлу раздащему файл нужно потратить вдвое больше места на диске чем занимает файл. 

### Архитектура сети

IPFS-сеть представляет из себя множество независимых компьютеров, на каждом из которых установлено необходимое программное обеспечение. Каждый из компьютеров, или другими словами узлов сети (nodes), раздает свои файлы и может участвовать в раздаче и поиске файлов, запрашиваемых пользователями сети.

Все узлы сети равнозначны, среди нет привелигированных узлов имеющих приоритет перед другими или имеющих возможность управлять остальными узлами. Однако часть узлов выполняют роль bootstrap-узлов. Такие узлы обычно поддерживаются создателями IPFS-сети и их адреса зашиты в код IPFS-клиентов. Каждый раз, когда запускается новый IPFS-клиент, он подключается к одному из бутстрап-узлов, чтобы получить адреса нескольких соседних узлов. Бутстрап-узлы это не единственный способ узнать адреса других компьютеров в сети, подробности можно найти в документации.

Итак, каждый IPFS-узел осведомлён о небольшом подмножестве других узлов IPFS-сети и может посылать им запросы на поиск файлов. Каждый узел поддерживает локальную хеш-таблицу с парами `(CID, данные)` для файлов, раздаваемых текущим узлом. Глобально все узлы вместе поддерживают распределенную хеш-таблицу, в IPFS используется реализация алгоритма [Kademlia DHT](https://en.wikipedia.org/wiki/Kademlia).

![Search](search.png)

Когда пользователь узла запрашивает у него файл с тем или иным _CID_, то узел сначала пытается найти файл с таким адресом у себя. Если файла нет, то он рассылает запросы на поиск файла соседним IPFS-нодам. Эти ноды также могут не иметь у себя запрошенного файла и тогда они перешлют запрос своим соседям. Причем в Kademlia реализован алгоритм выбора соседей достаточно умный, чтобы избежать циклических запросов вида _A -> B -> C -> A_. В конечном итоге, если файл с запрошенным CID действительно существует на одном из узлов сети, то он будет найден и адрес узла, раздающего этот файл, будет передан узлу запросившему файл. Далее исходный узел скачает файл напрямую с узла раздающего файл, минуя соседей.

Но что если запрошен несуществующий CID? Время поиска файла ограничивается параметром `QueryTimeout` и если файл не был найден за указанное время, то поиск будет прерван.

Скачанный файл попадёт в кеш ноды скачавшей файл и теперь эта нода также сможет раздавать его! Чем чаще запрашивается файл пользователями разных узлов сети, тем в кешах большего числа нод он осядет и тем проще и быстрее его будет скачать другим пользователям! Обычно, кеш хранится не дольше 24 часов, но может просуществовать и того меньше, если владелец узла запустит процедуру сборки мусора (garbage collection, gc). Таким образом, непопулярные файлы будут быстро вычищены из кешей других узлов и останутся только на оригинальной ноде, начавшей раздачу файла. 

> Это свойство не позволяет использовать IPFS как постоянное хранилище резервной копии ваших данных. Скорее всего, ваша нода большую часть времени будет единственным узлом распространяющим ваши файлы.

Если есть необходимость сделать так, чтобы файл раздавался не только нодой опубликовавшей его, но и другими, нужно чтобы другие ноды запинили (pin) этот файл, то есть отметили файл, чтобы он не удалялся при очистке кеша. Фактически, пинниг файла означает, что владелец ноды, запинившей файл, выделяет на своём компьютере место на жестком диске для хранения этого файла и часть своего сетевого трафика для его раздачи.

Очевидно, у участников сети нет мотивации бесплатно пинить файлы случайных пользователей и им нужно дать такую мотивацию. В интернете можно найти pinning-сервисы, которые за плату готовы пинить и раздавать ваши файлы вместо вас. О таких сервисах я расскажу позднее.

## Как взаимодействовать с IPFS

Предположим, кто-то прислал вам CID файла, расположенного в IPFS, как скачать этот файл? Или вы хотите разместить свой файл в IPFS, как это сделать? Есть несколько способов, рассмотрим основные. 

### Использование официального клиента IPFS

Этот способ самый универсальный, но и самый сложный. Если вам нужно только скачивть файлы из IPFS, то лучше сразу перейти к следующему разделу.

Разработчики IPFS создали [открытую спецификацию](https://specs.ipfs.tech/architecture/principles/) описывающую протокол взаимодействия узлов сети, поэтому любой желающий может создать свою реализацию этого протокола. Cуществует несколько реализаций протокола написанных на разных языках программирования. Официальная реализация называется [Kubo](https://docs.ipfs.tech/install/command-line/), она содержит утилиту командной строки (CLI tool) и веб-интерфейс для доступа к IPFS-сети.

Установка клиента тривиальна, я не буду останавливаться на этом подробнее, детали можно найти в документации по ссылке выше.

Имея установленную утилиту командной строки, мы можем легко добавить файл в IPFS:
```bash
echo "Hello, world!" > helloworld.txt
ipfs add helloworld.txt 
added QmeeLUVdiSTTKQqhWqsffYDtNvvvcTfJdotkNyi1KDEJtQ helloworld.txt
 14 B / 14 B [=====================================================================] 100.00%
 ```
Строка `QmeeLUVdiSTTKQqhWqsffYDtNvvvcTfJdotkNyi1KDEJtQ`, полученная в ответ на `ipfs add ...` это и есть CID добавленного файла. Теперь этим CID можно как-то поделиться, например через мессенджер или электронную почту, и любой желающий сможет скачать этот файл. Скачать до тех пор пока включен комьютер, раздающий этот файл, или пока этот файл не удалён из кешей узлов, скачавших файл.

Скачать файл из сети можно с помощью команды вида `ipfs get CID`, в примере с файлом выше команда будет иметь следующий вид:
```bash
ipfs get QmeeLUVdiSTTKQqhWqsffYDtNvvvcTfJdotkNyi1KDEJtQ
Saving file(s) to QmeeLUVdiSTTKQqhWqsffYDtNvvvcTfJdotkNyi1KDEJtQ
 14 B / 14 B [=====================================================================] 100.00% 0s
```

В IPFS сохраняется содержимое добавляемого файла, но не его имя, поэтому если при скачивании файла явно не указать имя, с которым его нужно сохранить, то по умолчанию в качестве имени будет использован CID.

Файлы добавленные в IPFS с помощью команды `ipfs add` автоматически пинятся на текущией машине. Список запиненых файлов можно посмотрить с помощью команды `ipfs pin ls`:
```bash
ipfs pin ls
QmeeLUVdiSTTKQqhWqsffYDtNvvvcTfJdotkNyi1KDEJtQ recursive
```

Запинить чужой файл на своем компьютере можно с помощью команды `ipfs pin add CID`.

### Веб-гейтвеи

Взаимодействие с IPFS-сетью способом описанным выше можно считать каноническим, но он слишком сложен, в случае если вам всего-лишь нужно скачать файл зная его CID. В таком случае самым простым и удобным способом является использование веб-гейтвеев (web gateway). Этот способ не требует установки дополнительного софта, достаточно иметь только браузер.

...что такое веб гейтвей?..

Список гейтов можно найти в интернете, два самых популярных это https://ipfs.io и https://dweb.link. Первый поддерживается авторами IPFS.

Чтобы получить доступ к файлу через гейт имея CID этого файла, достаточно в браузере открыть адрес вида `https://ipfs.io/ipfs/<CID>` (например, `https://ipfs.io/ipfs/QmeeLUVdiSTTKQqhWqsffYDtNvvvcTfJdotkNyi1KDEJtQ` для файла из предыдущего раздела). Если вместо CID у вас есть IPNS-адрес, то достаточно запросить `https://ipfs.io/ipns/<IPNS-hash>`.

### IPFS компаньоны для браузеров

Помимо способов выше, для доступа к данным в IPFS можно установить IPFS companion расширение к браузеру. С этим расширением браузер сможет автоматически обрабатывать ссылки вида `ipfs://<CID>` и `ipns://<IPNS-hash>`. При этом расширение достаточно умное для того чтобы понять установлен ли у вас локальный IPFS-клиент или нет. Если не установлен, то запросы будут перенаправлены на один из публичных гейтов. Если установлен, то запрос будет обработан локальным клиентом.

Разработчики браузера Brave пошли дальше, и интегрировали в него IPFS-клиент, поэтому он может обрабатывать запросы к IPFS-сети без установки плагина и локального клиента. Но, лично мне, связка "привычный браузер + плагин" кажется более разумной чем установка нового браузера. 

## Выводы

